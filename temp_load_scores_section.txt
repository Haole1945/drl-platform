            const initialAdvisorScores: Record<string, number> = {};
            
            // Only load from database if state is empty (not already entered by user)
            if (Object.keys(classMonitorSubCriteriaScores).length === 0 && 
                Object.keys(advisorSubCriteriaScores).length === 0 && 
                evalData.details) {
              evalData.details.forEach(detail => {
                // Find the criterion
                const criterion = criteriaResponse.data.find((c: Criteria) => c.id === detail.criteriaId);
                if (criterion && criterion.subCriteria) {
                  // Try to parse sub-criteria scores from comment (JSON format)
                  // Note: comment is mapped to both note and evidence in DTO
                  // note contains the raw comment, evidence may have prefix removed
                  let parsedSubCriteriaScores: any = null;
                  // Use note first (raw comment), fallback to evidence
                  const commentText = detail.note || detail.evidence;
                  
                  console.log('[DEBUG] Loading scores for criteria', detail.criteriaId, {
                    note: detail.note,
                    evidence: detail.evidence,
                    commentText: commentText?.substring(0, 100) + (commentText && commentText.length > 100 ? '...' : ''),
                    commentTextIsJSON: commentText?.trim().startsWith('{'),
                    classMonitorScore: detail.classMonitorScore,
                    advisorScore: detail.advisorScore
                  });
                  
                  if (commentText && commentText.trim().startsWith('{')) {
                    // It's JSON, parse it
                    try {
                      const parsed = JSON.parse(commentText);
                      console.log('[DEBUG] Parsed JSON from comment:', parsed);
                      if (parsed.scores) {
                        parsedSubCriteriaScores = parsed.scores;
                        console.log('[DEBUG] Found subCriteriaScores in JSON:', parsedSubCriteriaScores);
                      } else {
                        console.log('[DEBUG] No scores field in JSON, keys:', Object.keys(parsed));
                      }
                    } catch (e) {
                      // JSON parse failed
                      console.error('[DEBUG] Failed to parse JSON comment:', e.message);
                    }
                  } else if (commentText) {
                    // Not JSON (evidence string), will fallback to distribution
                    console.log('[DEBUG] Comment is not JSON (evidence string), will use fallback distribution');
                  } else {
                    console.log('[DEBUG] No comment text found for criteria', detail.criteriaId);
                  }
                  
                  // If we have saved sub-criteria scores in JSON, use them
                  if (parsedSubCriteriaScores) {
                    if (parsedSubCriteriaScores.classMonitorSubCriteria) {
                      Object.entries(parsedSubCriteriaScores.classMonitorSubCriteria).forEach(([subId, score]: [string, any]) => {
                        const subScoreKey = `${detail.criteriaId}_${subId}`;
                        initialClassMonitorScores[subScoreKey] = Number(score);
                      });
                    }
                    if (parsedSubCriteriaScores.advisorSubCriteria) {
                      Object.entries(parsedSubCriteriaScores.advisorSubCriteria).forEach(([subId, score]: [string, any]) => {
                        const subScoreKey = `${detail.criteriaId}_${subId}`;
                        initialAdvisorScores[subScoreKey] = Number(score);
                      });
                    }
                  } else {
                    // Fallback: distribute total score proportionally (for backward compatibility)
                    const totalMaxPoints = criterion.subCriteria.reduce((sum: number, s: any) => sum + s.maxPoints, 0);
                    // If class monitor score exists, distribute it
                    if (detail.classMonitorScore != null) {
                      criterion.subCriteria.forEach((sub: any) => {
                        const ratio = totalMaxPoints > 0 ? sub.maxPoints / totalMaxPoints : 0;
                        const distributedScore = Math.round(detail.classMonitorScore * ratio * 10) / 10;
                        const subScoreKey = `${detail.criteriaId}_${sub.id}`;
                        initialClassMonitorScores[subScoreKey] = distributedScore;
                      });
                    }
                    // If advisor score exists, distribute it separately
                    if (detail.advisorScore != null) {
                      criterion.subCriteria.forEach((sub: any) => {
                        const ratio = totalMaxPoints > 0 ? sub.maxPoints / totalMaxPoints : 0;
                        const distributedScore = Math.round(detail.advisorScore * ratio * 10) / 10;
                        const subScoreKey = `${detail.criteriaId}_${sub.id}`;
                        initialAdvisorScores[subScoreKey] = distributedScore;
                      });
                    }
                  }
                }
              });
              
              if (Object.keys(initialClassMonitorScores).length > 0) {
                setClassMonitorSubCriteriaScores(initialClassMonitorScores);
              }
              if (Object.keys(initialAdvisorScores).length > 0) {
                setAdvisorSubCriteriaScores(initialAdvisorScores);
              }
            }
            
            // Fetch file IDs for each criteria
            const filesMap: Record<number, number[]> = {};
            const token = getAuthToken();
