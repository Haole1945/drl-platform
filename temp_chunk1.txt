"use client";

import { useEffect, useState, useMemo } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { DashboardLayout } from '@/components/DashboardLayout';
import { ProtectedRoute } from '@/components/ProtectedRoute';
import { useAuth } from '@/contexts/AuthContext';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { getEvaluationById, submitEvaluation, approveEvaluation, rejectEvaluation, getActiveRubric, getCriteriaByRubric, deleteEvaluation } from '@/lib/evaluation';
import { StatusBadge } from '@/components/StatusBadge';
import { EvaluationHistory } from '@/components/EvaluationHistory';
import { canApproveClassLevel, canApproveAdvisorLevel, canApproveFacultyLevel } from '@/lib/role-utils';
import type { Evaluation, Rubric, Criteria, CriteriaWithSubCriteria,SubCriteria } from '@/types/evaluation';
import { Badge } from '@/components/ui/badge';
import { Loader2, Send, Check, X, Edit, ExternalLink, Trash2, Sparkles, CheckCircle2 } from 'lucide-react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { getOpenPeriod , getAuthToken} from '@/lib/api';
import { parseSubCriteria } from '@/lib/criteria-parser';
import { parseEvidence, getFileNameFromUrl } from '@/lib/evidence-parser';
import { formatDateTime, formatDate as formatDateUtil } from '@/lib/date-utils';
import { getScoringsuggestion } from '@/lib/api/ai-scoring';
import { GradeBadge } from '@/components/GradeBadge';
import { AppealButton } from '@/components/AppealButton';

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';

export default function EvaluationDetailPage() {
  const { user } = useAuth();
  const router = useRouter();
  const params = useParams();
  const { toast } = useToast();
  const [evaluation, setEvaluation] = useState<Evaluation | null>(null);
  const [rubric, setRubric] = useState<Rubric | null>(null);
  const [criteria, setCriteria] = useState<Criteria[]>([]);
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [rejectionReason, setRejectionReason] = useState('');
  const [approvalComment, setApprovalComment] = useState('');
  const [approvalScores, setApprovalScores] = useState<Record<number, number>>({}); // criteriaId -> score
  const [classMonitorSubCriteriaScores, setClassMonitorSubCriteriaScores] = useState<Record<string, number>>({}); // "criterionId_subCriteriaId" -> score (for class monitor)
  const [advisorSubCriteriaScores, setAdvisorSubCriteriaScores] = useState<Record<string, number>>({}); // "criterionId_subCriteriaId" -> score (for advisor)
  const [showRejectDialog, setShowRejectDialog] = useState(false);
  const [showApproveDialog, setShowApproveDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [openPeriod, setOpenPeriod] = useState<any>(null);
  const [canEditInPeriod, setCanEditInPeriod] = useState(false);
  const [criteriaFiles, setCriteriaFiles] = useState<Record<number, number[]>>({}); // criteriaId -> fileIds[]
  const [aiScores, setAiScores] = useState<Record<string, { score: number; maxScore: number; loading?: boolean }>>({}); // subCriteriaId -> { score, maxScore }

  const evaluationId = params?.id ? parseInt(params.id as string) : null;
  const API_BASE = process.env.NEXT_PUBLIC_API_BASE || 'http://localhost:8080/api';

  // Parse criteria with sub-criteria and map with evaluation details
  const criteriaWithSubCriteria = useMemo<CriteriaWithSubCriteria[]>(() => {
    if (!criteria.length || !evaluation) return [];

    return criteria.map(criterion => {
      const subCriteria = parseSubCriteria(criterion.orderIndex, criterion.description || '');
      const detail = evaluation.details.find(d => d.criteriaId === criterion.id);
      
      // Parse evidence to get sub-criteria scores and files
      const parsedEvidence = detail?.evidence ? parseEvidence(detail.evidence) : [];
      
      // Map sub-criteria with scores and evidence
      // Scores are now stored in evidence string with format: "SCORES:1.1=3,1.2=10|EVIDENCE:..."
      const subCriteriaWithData = subCriteria.map(sub => {
        const evidenceData = parsedEvidence.find(e => e.subCriteriaId === sub.id);
        // Get score from parsed evidence (if available)
        // If no evidenceData found, check if score exists in parsedEvidence (for scores without evidence)
        const score = evidenceData?.score ?? 
          (parsedEvidence.find(e => e.subCriteriaId === sub.id && e.score !== undefined)?.score ?? 0);
        // Convert fileUrls to string (comma-separated URLs)
        const evidenceString = (evidenceData?.fileUrls || []).join(', ');
        return {
          ...sub,
          score: score, // Use score from parsed evidence
          evidence: evidenceString, // Store as string to match SubCriteria type
        };
      });

      // Get scores from detail
      const studentScore = detail?.score || detail?.selfScore || 0;
      const classMonitorScore = detail?.classMonitorScore || null;
      const advisorScore = detail?.advisorScore || null;
      
      // Calculate total score (use advisor score if available, else class monitor, else student)
      const finalScore = advisorScore ?? classMonitorScore ?? studentScore;
      
      return {
        ...criterion,
        subCriteria: subCriteriaWithData,
        totalScore: studentScore,
        classMonitorScore: classMonitorScore,
        advisorScore: advisorScore,
        finalScore: finalScore, // Score to display (advisor > class monitor > student)
      };
    });
  }, [criteria, evaluation]);

  // Use shared date utility for consistent formatting
  const formatDate = formatDateTime;

  // Calculate total score - use API value first, fallback to calculated from details
  const totalScore = useMemo(() => {
    // Prefer totalScore/totalPoints from API (more reliable)
    if (evaluation?.totalPoints !== undefined && evaluation.totalPoints !== null) {
      return evaluation.totalPoints;
    }
    if (evaluation?.totalScore !== undefined && evaluation.totalScore !== null) {
      return evaluation.totalScore;
    }
    // Fallback: calculate from criteria details
    return criteriaWithSubCriteria.reduce((sum, c) => sum + c.totalScore, 0);
  }, [criteriaWithSubCriteria, evaluation]);

  useEffect(() => {
    if (!evaluationId) {
      router.push('/evaluations');
      return;
    }

    const loadData = async () => {
      try {
        // Load evaluation
        const evalResponse = await getEvaluationById(evaluationId);
        if (!evalResponse.success || !evalResponse.data) {
          toast({
            title: "Lá»—i",
            description: "KhÃ´ng tÃ¬m tháº¥y Ä‘Ã¡nh giÃ¡.",
            variant: "destructive"
          });
          router.push('/evaluations');
          return;
        }

        const evalData = evalResponse.data;
        setEvaluation(evalData);

        // Load rubric and criteria
        const classCode = user?.classCode;
        const rubricResponse = await getActiveRubric(undefined, classCode);
        if (rubricResponse.success && rubricResponse.data) {
          setRubric(rubricResponse.data);
          
          const criteriaResponse = await getCriteriaByRubric(rubricResponse.data.id);
          if (criteriaResponse.success && criteriaResponse.data) {
            setCriteria(criteriaResponse.data);
            
            // Initialize sub-criteria scores from existing scores if available
            // Only initialize if state is empty (first load), don't override user's entered scores
            const initialClassMonitorScores: Record<string, number> = {};
            const initialAdvisorScores: Record<string, number> = {};
            
            // Only load from database if state is empty (not already entered by user)
            if (Object.keys(classMonitorSubCriteriaScores).length === 0 && 
                Object.keys(advisorSubCriteriaScores).length === 0 && 
                evalData.details) {
              evalData.details.forEach(detail => {
                // Find the criterion
                const criterion = criteriaResponse.data.find((c: Criteria) => c.id === detail.criteriaId);
                if (criterion && criterion.subCriteria) {
                  // Try to parse sub-criteria scores from comment (JSON format)
                  // Note: comment is mapped to both note and evidence in DTO
                  // note contains the raw comment, evidence may have prefix removed
                  let parsedSubCriteriaScores: any = null;
                  // Use note first (raw comment), fallback to evidence
                  const commentText = detail.note || detail.evidence;
                  
                  console.log('[DEBUG] Loading scores for criteria', detail.criteriaId, {
                    note: detail.note,
                    evidence: detail.evidence,
                    commentText: commentText?.substring(0, 100) + (commentText && commentText.length > 100 ? '...' : ''),
                    commentTextIsJSON: commentText?.trim().startsWith('{'),
                    classMonitorScore: detail.classMonitorScore,
                    advisorScore: detail.advisorScore
                  });
                  
                  if (commentText && commentText.trim().startsWith('{')) {
                    // It's JSON, parse it
                    try {
                      const parsed = JSON.parse(commentText);
                      console.log('[DEBUG] Parsed JSON from comment:', parsed);
                      if (parsed.scores) {
                        parsedSubCriteriaScores = parsed.scores;
                        console.log('[DEBUG] Found subCriteriaScores in JSON:', parsedSubCriteriaScores);
                      } else {
                        console.log('[DEBUG] No scores field in JSON, keys:', Object.keys(parsed));
                      }
                    } catch (e) {
                      // JSON parse failed
                      console.error('[DEBUG] Failed to parse JSON comment:', e.message);
                    }
                  } else if (commentText) {
                    // Not JSON (evidence string), will fallback to distribution
                    console.log('[DEBUG] Comment is not JSON (evidence string), will use fallback distribution');
                  } else {
                    console.log('[DEBUG] No comment text found for criteria', detail.criteriaId);
                  }
                  
                  // If we have saved sub-criteria scores in JSON, use them
                  if (parsedSubCriteriaScores) {
                    if (parsedSubCriteriaScores.classMonitorSubCriteria) {
                      Object.entries(parsedSubCriteriaScores.classMonitorSubCriteria).forEach(([subId, score]: [string, any]) => {
                        const subScoreKey = `${detail.criteriaId}_${subId}`;
                        initialClassMonitorScores[subScoreKey] = Number(score);
                      });
                    }
                    if (parsedSubCriteriaScores.advisorSubCriteria) {
                      Object.entries(parsedSubCriteriaScores.advisorSubCriteria).forEach(([subId, score]: [string, any]) => {
                        const subScoreKey = `${detail.criteriaId}_${subId}`;
                        initialAdvisorScores[subScoreKey] = Number(score);
                      });
                    }
                  } else {
                    // Fallback: distribute total score proportionally (for backward compatibility)
                    const totalMaxPoints = criterion.subCriteria.reduce((sum: number, s: any) => sum + s.maxPoints, 0);
                    // If class monitor score exists, distribute it
                    if (detail.classMonitorScore != null) {
                      criterion.subCriteria.forEach((sub: any) => {
                        const ratio = totalMaxPoints > 0 ? sub.maxPoints / totalMaxPoints : 0;
                        const distributedScore = Math.round(detail.classMonitorScore * ratio * 10) / 10;
                        const subScoreKey = `${detail.criteriaId}_${sub.id}`;
                        initialClassMonitorScores[subScoreKey] = distributedScore;
                      });
                    }
                    // If advisor score exists, distribute it separately
                    if (detail.advisorScore != null) {
                      criterion.subCriteria.forEach((sub: any) => {
                        const ratio = totalMaxPoints > 0 ? sub.maxPoints / totalMaxPoints : 0;
                        const distributedScore = Math.round(detail.advisorScore * ratio * 10) / 10;
                        const subScoreKey = `${detail.criteriaId}_${sub.id}`;
                        initialAdvisorScores[subScoreKey] = distributedScore;
                      });
                    }
                  }
                }
              });
              
              if (Object.keys(initialClassMonitorScores).length > 0) {
                setClassMonitorSubCriteriaScores(initialClassMonitorScores);
              }
              if (Object.keys(initialAdvisorScores).length > 0) {
                setAdvisorSubCriteriaScores(initialAdvisorScores);
              }
            }
            
            // Fetch file IDs for each criteria
            const filesMap: Record<number, number[]> = {};
            const token = getAuthToken();
            console.log('[AI Debug] Starting file fetch - token:', !!token, 'evaluationId:', evaluationId, 'criteriaCount:', criteriaResponse.data.length);
            
            if (token && evaluationId) {
              console.log('[AI Debug] Fetching files for evaluation:', evaluationId);
              
              // First, try to get files from API
              await Promise.all(
                criteriaResponse.data.map(async (criterion: Criteria) => {
                  try {
                    const url = `${API_BASE}/files/evaluation/${evaluationId}/criteria/${criterion.id}`;
                    console.log('[AI Debug] Fetching files for criteria:', criterion.id, 'URL:', url);
                    const response = await fetch(url, {
                      headers: {
                        'Authorization': `Bearer ${token}`,
                      },
                    });
                    console.log('[AI Debug] Response status for criteria', criterion.id, ':', response.status);
                    if (response.ok) {
                      const data = await response.json();
                      console.log('[AI Debug] Files response for criteria', criterion.id, ':', data);
                      if (data.success && data.data && Array.isArray(data.data)) {
                        const fileIds = data.data.map((f: any) => f.id).filter((id: any) => id != null);
                        if (fileIds.length > 0) {
                          filesMap[criterion.id] = fileIds;
                          console.log('[AI Debug] File IDs for criteria', criterion.id, ':', fileIds);
                        } else {
                          console.log('[AI Debug] No file IDs found for criteria', criterion.id);
                        }
                      } else {
                        console.log('[AI Debug] No files in response for criteria', criterion.id, 'data:', data);
                      }
                    } else {
                      const errorText = await response.text().catch(() => '');
                      console.warn('[AI Debug] Failed to fetch files for criteria', criterion.id, 'Status:', response.status, 'Error:', errorText);
                    }
                  } catch (err) {
                    console.error('[AI Debug] Error fetching files for criteria', criterion.id, ':', err);
                  }
                })
              );
              
              // If no files found via API, try to sync files with evaluation
              // This is a one-time fix for existing evaluations where files weren't linked
              if (Object.keys(filesMap).length === 0 && evalData.details) {
                const hasEvidence = evalData.details.some((d: any) => d.evidence && d.evidence.match(/\/files\/evidence\/[^\s,]+/g));
                
                if (hasEvidence) {
                  console.log('[AI Debug] No files from API but evidence exists, syncing files with evaluation');
                  
                  try {
                    // Call sync endpoint to link files with evaluation
                    const syncUrl = `${API_BASE}/evaluations/${evaluationId}/sync-files`;
                    const syncResponse = await fetch(syncUrl, {
                      method: 'POST',
                      headers: {
                        'Authorization': `Bearer ${token}`,
                      },
                    });
                    
                    if (syncResponse.ok) {
                      console.log('[AI Debug] Files synced successfully, fetching again');
                      // Fetch files again after sync
                      await Promise.all(
                        criteriaResponse.data.map(async (criterion: Criteria) => {
                          try {
                            const url = `${API_BASE}/files/evaluation/${evaluationId}/criteria/${criterion.id}`;
                            const response = await fetch(url, {
                              headers: {
                                'Authorization': `Bearer ${token}`,
                              },
                            });
                            if (response.ok) {
                              const data = await response.json();
                              if (data.success && data.data && Array.isArray(data.data)) {
                                const fileIds = data.data.map((f: any) => f.id).filter((id: any) => id != null);
                                if (fileIds.length > 0) {
                                  filesMap[criterion.id] = fileIds;
                                  console.log('[AI Debug] Found file IDs after sync:', fileIds);
                                }
                              }
                            }
                          } catch (err) {
                            console.error('[AI Debug] Error fetching files after sync:', err);
                          }
                        })
                      );
                    } else {
                      const errorText = await syncResponse.text().catch(() => '');
                      console.warn('[AI Debug] Sync failed, Status:', syncResponse.status, 'Error:', errorText);
                    }
                  } catch (err) {
                    console.error('[AI Debug] Error syncing files:', err);
                  }
                }
              }
              
              console.log('[AI Debug] Final filesMap:', filesMap);
              setCriteriaFiles(filesMap);
            } else {
              console.warn('[AI Debug] Cannot fetch files - token:', !!token, 'evaluationId:', evaluationId);
            }
          }
        }
      } catch (error: any) {
        // If we reach here, it means all retries failed - this is a real error
        // Retry logic in API client handles transient errors automatically
        // Check if this is a 404 (evaluation not found) vs other errors
        const errorMessage = error?.message || '';
        const isNotFound = errorMessage.includes('404') || errorMessage.includes('KhÃ´ng tÃ¬m tháº¥y');
        
        toast({
          title: "Lá»—i",
          description: isNotFound 
            ? "KhÃ´ng tÃ¬m tháº¥y Ä‘Ã¡nh giÃ¡ nÃ y." 
            : "KhÃ´ng thá»ƒ táº£i Ä‘Ã¡nh giÃ¡. Vui lÃ²ng thá»­ láº¡i sau.",
          variant: "destructive"
        });
        
        // Only redirect if it's a 404 or persistent error (not network/connection errors)
        // Network errors might be transient, so we don't redirect immediately
        const isNetworkError = errorMessage.includes('fetch') || errorMessage.includes('káº¿t ná»‘i');
        if (isNotFound || !isNetworkError) {
          router.push('/evaluations');
        }
      } finally {
        setLoading(false);
      }
    };

    loadData();
  }, [evaluationId, router, toast]);

  // Helper function to parse date from string or number array [year, month, day]
  const parseDate = (dateValue: string | number[]): Date => {
    if (typeof dateValue === 'string') {
      return new Date(dateValue);
    }
    if (Array.isArray(dateValue) && dateValue.length >= 3) {
      // Java LocalDate format: [year, month, day]
      // Note: JavaScript Date month is 0-indexed, Java LocalDate month is 1-indexed
      return new Date(dateValue[0], dateValue[1] - 1, dateValue[2]);
    }
    return new Date();
  };

  // Check if evaluation period is still open for editing (for submitted evaluations)
  useEffect(() => {
    const checkPeriod = async () => {
      if (evaluation && (evaluation.status === 'SUBMITTED' || evaluation.status === 'CLASS_APPROVED' || evaluation.status === 'FACULTY_APPROVED')) {
        try {
          const periodResponse = await getOpenPeriod();
          if (periodResponse.success && periodResponse.data) {
            setOpenPeriod(periodResponse.data);
            // Check if current date is within period
            const today = new Date();
            const startDate = Array.isArray(periodResponse.data.startDate)
              ? new Date(periodResponse.data.startDate[0], periodResponse.data.startDate[1] - 1, periodResponse.data.startDate[2])
              : new Date(periodResponse.data.startDate);
            const endDate = Array.isArray(periodResponse.data.endDate)
              ? new Date(periodResponse.data.endDate[0], periodResponse.data.endDate[1] - 1, periodResponse.data.endDate[2])
              : new Date(periodResponse.data.endDate);
            setCanEditInPeriod(today >= startDate && today <= endDate);
          } else {
            setCanEditInPeriod(false);
          }
        } catch (error) {
          // Silently handle period check failure - it's not critical
          setCanEditInPeriod(false);
        }
      } else {
        setCanEditInPeriod(false);
      }
    };
    if (evaluation) {
      checkPeriod();
    }
  }, [evaluation]);

  // Auto-run AI analysis when files are loaded
  useEffect(() => {
    const runAiAnalysis = async () => {
      if (!criteriaWithSubCriteria.length || !Object.keys(criteriaFiles).length || !evaluation) {
        return;
      }

      const token = getAuthToken();
      if (!token) {
        return;
      }

      // Run AI analysis for each criterion that has files
      for (const criterion of criteriaWithSubCriteria) {
        const fileIds = criteriaFiles[criterion.id] || [];
        if (fileIds.length === 0) {
          continue;
        }

        // Check if this criterion has sub-criteria with evidence
        const hasSubCriteriaWithEvidence = criterion.subCriteria.some(sub => sub.evidence && sub.evidence.length > 0);
        if (!hasSubCriteriaWithEvidence) {
          continue;
        }

        // Mark sub-criteria as loading
        const loadingScores: Record<string, { score: number; maxScore: number; loading: boolean }> = {};
        criterion.subCriteria.forEach(sub => {
          if (sub.evidence && sub.evidence.length > 0) {
            loadingScores[sub.id] = { score: 0, maxScore: sub.maxPoints, loading: true };
          }
        });
        setAiScores(prev => ({ ...prev, ...loadingScores }));

        try {
          const response = await getScoringsuggestion(
            {
              criteriaId: criterion.id,
              evidenceFileIds: fileIds,
              maxScore: criterion.maxPoints,
              subCriteria: criterion.subCriteria.map(sub => ({
                id: sub.id,
                name: sub.name,
                description: sub.description,
                maxPoints: sub.maxPoints
              }))
            },
            token
          );

          if (response.subCriteriaScores) {
            const newScores: Record<string, { score: number; maxScore: number }> = {};
            response.subCriteriaScores.forEach((subScore: any) => {
              newScores[subScore.subCriteriaId] = {
                score: subScore.suggestedScore,
                maxScore: subScore.maxScore
              };
            });
            setAiScores(prev => ({ ...prev, ...newScores }));
          }
